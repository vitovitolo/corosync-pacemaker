#!KAMAILIO
# define WITH_DEBUG
#!define WITH_CHECKROUTE
#!define WITH_EXEC
# Kamailio (OpenSER) SIP Server v4.0 - default configuration script
#     - web: http://www.kamailio.org
#     - git: http://sip-router.org
#
# Direct your questions about this file to: <sr-users@lists.sip-router.org>
#
# Refer to the Core CookBook at http://www.kamailio.org/wiki/
# for an explanation of possible statements, functions and parameters.
#
# Edited by: https://github.com/vitovitolo

####### Include Local Config If Exists #########
import_file "kamailio-local.cfg"

####### Defined Values #########

# *** Value defines - IDs used later in config

####### Global Parameters #########

### LOG Levels: 3=DBG, 2=INFO, 1=NOTICE, 0=WARN, -1=ERR
#!ifdef WITH_DEBUG
debug=4
log_stderror=yes
#!else
debug=2
log_stderror=no
#!endif

memdbg=5
memlog=5

log_facility=LOG_LOCAL6

fork=yes
children=12

/* uncomment the next line to disable TCP (default on) */
disable_tcp=yes

/* uncomment the next line to disable the auto discovery of local aliases
   based on reverse DNS on IPs (default on) */
#auto_aliases=no

/* add local domain aliases */
alias="test.es"
alias="XX.YY.ZZZ.WWW"
alias="127.0.0.1"

/* uncomment and configure the following line if you want Kamailio to
   bind on a specific interface/port/proto (default bind on all available) */
#virtual ip address
listen=udp:10.0.6.4:5060
listen=udp:127.0.0.1:5060

/* port to listen to
 * - can be specified more than once if needed to listen on many ports */
port=5060


# life time of TCP connection when there is no traffic
# - a bit higher than registration expires to cope with UA behind NAT
tcp_connection_lifetime=3605

#Server Header Value for replies generated by Kamailio.
#server_header="User-Agent: REDIRECT Server 1.0.0"

server_signature=no

####### Custom Parameters #########

# These parameters can be modified runtime via RPC interface
# - see the documentation of 'cfg_rpc' module.
#
# Format: group.id = value 'desc' description
# Access: $sel(cfg_get.group.id) or @cfg_get.group.id
#

#!ifdef WITH_CHECKROUTE
checkroute.domain = "cloudservices.stonework.es" desc "CHECKRoute Domain Address"
checkroute_typeA.bindip = "typeA_ip"
checkroute_typeA.bindport = "5060"
checkroute_typeB.bindip = "typeB-ip"
checkroute_typeB.bindport = "5060"
typeB.bindip = "1.1.1.1" desc "typeB switch address"
typeA.bindip = "2.2.2.2" desc "typeA switch address"
dev.bindip = "3.3.3.3" desc "typeA switch address"
#!endif

####### Modules Section ########

# set paths to location of modules (to sources or installation folders)
#!ifdef WITH_SRCPATH
mpath="modules_k:modules"
#!else
mpath="/usr/lib64/kamailio/modules/"
#!endif


loadmodule "mi_fifo.so"
loadmodule "kex.so"
loadmodule "corex.so"
loadmodule "tm.so"
loadmodule "tmx.so"
loadmodule "sl.so"
loadmodule "rr.so"
loadmodule "pv.so"
loadmodule "maxfwd.so"
loadmodule "textops.so"
loadmodule "siputils.so"
loadmodule "xlog.so"
loadmodule "sanity.so"
loadmodule "ctl.so"


#!ifdef WITH_ANTIFLOOD
loadmodule "htable.so"
loadmodule "pike.so"
#!endif


#!ifdef WITH_DEBUG
loadmodule "debugger.so"
#!endif

#!ifdef WITH_EXEC
loadmodule "exec.so"
#!endif WITH_EXEC

loadmodule "app_python.so"

# ----------------- setting module-specific parameters ---------------

# ----- mi_fifo params -----
modparam("mi_fifo", "fifo_name", "/tmp/kamailio_fifo")

# ----- tm params -----
# auto-discard branches from previous serial forking leg
modparam("tm", "failure_reply_mode", 3)
# default retransmission timeout: 30sec
modparam("tm", "fr_timer", 30000)
# default invite retransmission timeout after 1xx: 120sec
modparam("tm", "fr_inv_timer", 120000)


# ----- rr params -----
# add value to ;lr param to cope with most of the UAs
modparam("rr", "enable_full_lr", 1)
# do not append from tag to the RR (no need for this script)
modparam("rr", "append_fromtag", 0)



#!ifdef WITH_ANTIFLOOD
# ----- pike params -----
modparam("pike", "sampling_time_unit", 2)
modparam("pike", "reqs_density_per_unit", 16)
modparam("pike", "remove_latency", 4)

# ----- htable params -----
# ip ban htable with autoexpire after 5 minutes
modparam("htable", "htable", "ipban=>size=8;autoexpire=300;")
#!endif

#!ifdef WITH_XMLRPC
# ----- xmlrpc params -----
modparam("xmlrpc", "route", "XMLRPC");
modparam("xmlrpc", "url_match", "^/RPC")
#!endif

#!ifdef WITH_DEBUG
# ----- debugger params -----
modparam("debugger", "cfgtrace", 1)
#!endif

#!ifdef WITH_EXEC
modparam("exec", "time_to_kill", 2)
modparam("exec", "setvars", 0)
#!endif WITH_EXEC

modparam("siputils", "options_accept", "")

modparam("app_python", "script_name", "/etc/kamailio/getHTTP.py")
modparam("app_python", "mod_init_function", "mod_init")
modparam("app_python", "child_init_method", "child_init")


####### Routing Logic ########

# Main SIP request routing logic
# - processing of any incoming SIP request starts with this route
# - note: this is the same as route { ... }
request_route {

	#LOG
	route(LOG);
	# per request initial checks
	route(REQINIT);

	#Send 200 ok to options sip msg
	route(OPTIONS);

	if (is_method("INVITE")) {
		sl_send_reply("100", "Trying");
		#Set backend type due to ip address
                route(SET_BACKEND_TYPE);
        }
    else {
        xlog("L_NOTICE", "Dropping $rm SIP message");
    }

	# get data from CHECKRoute external cloud service
	route(CHECKROUTE);

	# Redirect msg to adecuate provider
	route(REDIRECT);

	if ($rU==$null)
	{
		# request with no Username in RURI
		sl_send_reply("484","Address Incomplete");
		exit;
	}

}

route[LOG] {
	if ($si!="127.0.0.1") {
		xlog("L_NOTICE", "LOG: Received SIP message: $rm  from ip: $si  r-uri: $ru ");
	}
}

# Send 200 OK to ping OPTIONS messages
route[OPTIONS] {
   if (uri==myself) {
        if ((method==OPTIONS) && (! uri=~"sip:.*[@]+.*")) {
                #xlog("L_NOTICE", "Sending OPTIONS response");
                options_reply();
        }
   }
}

#Set backend due to source IP address
route[SET_BACKEND_TYPE] {
	if ($si==$sel(cfg_get.typeB.bindip)) {
		$var(backend_type) = "TYPEB" ;
		#Set ip and port request to CHECKroute
		$var(checkroute_bindip) = $sel(cfg_get.checkroute_typeB.bindip) ;
		$var(checkroute_bindport) = $sel(cfg_get.checkroute_typeB.bindport) ;
		#Extract resource group id from User-Agent header. This field will be sent to CHECKRoute.
        	$var(rg_id) = $(ua{s.select,2,-}{s.substr,4,0});
        	# Clean up DDI, URL encoding the pound (#) -> %23
        	$var(ddi) = $(tU{s.escape.user});
		xlog("L_NOTICE", "SET_BACKEND_TYPE: Setting TYPEB backend type.");
	}
	else if ($si==$sel(cfg_get.typeA.bindip)) {
		$var(backend_type) = "TYPEA";
		#Set ip and port request to CHECKroute
		$var(checkroute_bindip) = $sel(cfg_get.checkroute_typeA.bindip) ;
        	$var(checkroute_bindport) = $sel(cfg_get.checkroute_typeA.bindport) ;
		#Extract resource group id from Request-URI Username field. This value ALLWAYS must be 4 digits size.
        	$var(rg_id) = $(rU{s.substr,0,4});
        	# Clean up DDI, URL encoding the pound (#) -> %23
        	$var(ddi) = $(rU{s.substr,4,0});
		xlog("L_NOTICE", "SET_BACKEND_TYPE: Setting TYPEA backend type.");
	}
    #THIS SECTION SHOULD BE DELETE IN PRO
	else if ($si==$sel(cfg_get.dev.bindip)) {
                $var(backend_type) = "TYPEB";
                #Set ip and port request to CHECKroute
                $var(checkroute_bindip) = $sel(cfg_get.checkroute_typeB.bindip) ;
                $var(checkroute_bindport) = $sel(cfg_get.checkroute_typeB.bindport) ;
		#Extract resource group id from User-Agent header. This field will be sent to CHECKRoute.
                $var(rg_id) = $(ua{s.select,2,-}{s.substr,4,0});
                # Clean up DDI, URL encoding the pound (#) -> %23
                $var(ddi) = $(tU{s.escape.user});
                xlog("L_NOTICE", "SET_BACKEND_TYPE: Setting TYPEB backend type.");
        }
	else {
		xlog("L_NOTICE", "SET_BACKEND_TYPE: ERROR checking source ip: $si");
                append_to_reply("Reason: Q.850; cause=34\r\n");
                sl_send_reply("503", "Service unavailable");
		exit;
	}
}


route[CHECKROUTE] {
	#Set request from parameters
        $var(httpRequest) = 'http://'+$var(checkroute_bindip)+':'+$var(checkroute_bindport)+'/checkroute/'+$var(rg_id)+'//'+$fU+'/'+$var(ddi)+'/'+$hdr(Call-ID);
        xlog("L_NOTICE", "CHECKROUTE: Request: $var(httpRequest) ");
        #Run external script in python to send HTTP request to CHECKROUTE
        python_exec("getHTTP",$var(httpRequest));
        #Get http response from destination URI
        $var(http_response) = $du ;
        #Parse jizo http response
        $var(ssaction) =   $(var(http_response){s.select,0,,});
        $var(ssresponse) =     $(var(http_response){s.select,1,,});
        $var(ssprefix) =   $(var(http_response){s.select,2,,});
        $var(ssprocesstime) = $(var(http_response){s.select,3,,});
        $var(sscallid) =   $(var(http_response){s.select,4,,});

        #CHECKRoute accepts routing for this call. Seting provider prefix in Request-Username (Number) and send 302 SIP Redirect.
        if ($var(ssaction) == "ACCEPT" ) {
		xlog("L_NOTICE", "CHECKROUTE: Response: $var(http_response) \n");
                route(REDIRECT);
        }
        #CHECKRoute  has no more providers to try. Sending apropiate SIP/ISUP cause code to typeB
        else if ($var(ssaction) == "REJECT" ) {
		xlog("L_NOTICE", "CHECKROUTE: Response: $var(http_response) \n");
                #Set SIP/ISUP cause code and reject the call
                route(REJECT);
        }
        else if ($var(ssaction) =~ "ERROR" ) {
		xlog("L_NOTICE", "CHECKROUTE: Response: $var(http_response) \n");
                $var(ssaction) = "REJECT";
                route(REJECT);
        }
        else {
                xlog("L_NOTICE", "CHECKROUTE: CHECKroute is going crazy! Cant understand the response. Rejecting the call.");
                $var(ssaction) = "REJECT";
                $var(ssresponse) = "CHECKROUTE_CRAZY";
                route(REJECT);
        }


}

#Mapping of CHECKRoute reject replies and ISUP casue codes
route[REJECT] {
        #Initialize variables
        $var(code) = "";
        $var(isup_code)= "";
        $var(sip_code)= "";
        $var(sip_cause) = "";
        #Get CHECKRoute Cause
        $var(code) = $var(ssresponse);
        if ( $var(code) =~ "^CLIENT_RANGE_BLACKLISTED$|^NO_CURRENT_RATE_FOR_RANGE$|^NO_PROVIDERS_LEFT$|^RANGE_NOT_IN_ROUTE_TABLE$|^RANGE_NOT_IN_SYSTEM$|^WRONG_DDI$" ) {
                $var(isup_code)= "3";
                $var(sip_code)= 404;
                $var(sip_cause) = "Not Found";
        }
        else if ( $var(code) =~ "^BAD_DATA$|^BAD_REQUEST$|^CALL_ALREADY_REJECTED$|^CLIENT_PREFIX_DOESNT_MATCH$|^ERROR_GET_ROUTE$|^ERROR$|^ICX_NOT_IN_GROUP$|^ICX_NOT_REGISTERED$" ) {
                $var(isup_code)= "21";
                $var(sip_code)= 403;
                $var(sip_cause) = "Forbidden";
        }
        else {
                #xlog("L_NOTICE", "REJECT: Unspecified cause of rejection from CHECKRoute: $var(code)");
                $var(isup_code)= "34";
                $var(sip_code)= 503;
                $var(sip_cause) = "Service unavailable";
        }
        xlog("L_NOTICE", "REJECT: Sending cause code   SIP: $var(sip_code)  $var(sip_cause)   ISUP: $var(isup_code).\n");
        append_to_reply("Reason: Q.850; cause=$var(isup_code)\r\n");
        sl_send_reply("$var(sip_code)", "$var(sip_cause)");
        exit;
}

# Rewrite Request Uri and send 302 SIP Redirect
route[REDIRECT] {
        #Append RG-ID as a prefix in the number

	if ($var(backend_type)=="TYPEB") {
	        $ru = 'sip:'+$var(ssresponse)+$rU+'@'+$sel(cfg_get.checkroute.domain)+':5060';
	}
	else if ($var(backend_type)=="TYPEA") {
        	$ru = 'sip:'+$var(ssresponse)+'@'+$sel(cfg_get.checkroute.domain)+':5060';
	}
	else {
		#Error setting backend type
		xlog("L_NOTICE", "REDIRECT: ERROR can't get backend type.");
		append_to_reply("Reason: Q.850; cause=34\r\n");
		sl_send_reply("503", "Service unavailable");
	        exit;
	}
        #xlog("L_NOTICE", "REDIRECT: Rewriting URI appending next provider with RG-ID: $var(ssresponse) ");
        sl_send_reply("302", "Moved Temporarily");
        exit;
}


# Per SIP request initial checks
route[REQINIT] {
#!ifdef WITH_ANTIFLOOD
	# flood dection from same IP and traffic ban for a while
	# be sure you exclude checking trusted peers, such as pstn gateways
	# - local host excluded (e.g., loop to self)
	if(src_ip!=myself)
	{
		if($sht(ipban=>$si)!=$null)
		{
			# ip is already blocked
			xdbg("request from blocked IP - $rm from $fu (IP:$si:$sp)\n");
			exit;
		}
		if (!pike_check_req())
		{
			xlog("L_ALERT","ALERT: pike blocking $rm from $fu (IP:$si:$sp)\n");
			$sht(ipban=>$si) = 1;
			exit;
		}
	}
#!endif

	if (!mf_process_maxfwd_header("10")) {
		xlog("L_NOTICE", "REQINIT: 483 Too Many Hops");
		sl_send_reply("483","Too Many Hops");
		exit;
	}

	if(!sanity_check("1511", "7"))
	{
		xlog("L_NOTICE", "REQINIT: Malformed SIP message from $si:$sp\n");
		exit;
	}
}
